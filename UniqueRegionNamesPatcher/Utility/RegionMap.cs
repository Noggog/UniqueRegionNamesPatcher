using Mutagen.Bethesda;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using Mutagen.Bethesda.Plugins.Cache;

namespace UniqueRegionNamesPatcher.Utility
{
    /// <summary>
    /// This is a custom object used to parse and interact with the region/cell map generated by the ParseImage project on the dev branch.
    /// </summary>
    public class RegionMap
    {
        /// <summary>
        /// Constructor that parses an already-serialized file.
        /// </summary>
        /// <param name="fileContent"><see cref="byte[]"/> containing the serialized contents of the region map file.</param>
        /// <param name="state">Reference of the <see cref="IPatcherState"/> object passed to the <see cref="Program.RunPatch(IPatcherState{ISkyrimMod, ISkyrimModGetter})"/> function.</param>
        //public RegionMap(byte[] fileContent, ref IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        //{
        //    Map = new();
        //    Regions = new();
        //    linkCache = state.PatchMod.ToMutableLinkCache();
        //    Parse(new MemoryStream(fileContent), ref state);
        //}
        /// <summary>
        /// Constructor that accepts a pre-defined <see cref="Stream"/> object.
        /// </summary>
        /// <param name="stream">A pre-defined <see cref="Stream"/> derived object.</param>
        /// <param name="state">Reference of the <see cref="IPatcherState"/> object passed to the <see cref="Program.RunPatch(IPatcherState{ISkyrimMod, ISkyrimModGetter})"/> function.</param>
        public RegionMap(Stream stream, ref IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Map = new();
            Regions = new();
            linkCache = state.PatchMod.ToMutableLinkCache();
            Parse(stream, ref state);
        }

        /// <summary>
        /// Parses the given stream, and populates the <see cref="Map"/> and <see cref="Regions"/> members.
        /// </summary>
        /// <param name="stream">A <see cref="Stream"/> object with the contents of the region map file.</param>
        /// <param name="state">Reference of the <see cref="IPatcherState"/> object passed to the <see cref="Program.RunPatch(IPatcherState{ISkyrimMod, ISkyrimModGetter})"/> function.</param>
        private void Parse(Stream stream, ref IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            using StreamReader sr = new(stream);

            string header = string.Empty;
            bool doRead = false;

            int ln = 0;
            for (string? line = sr.ReadLine(); !sr.EndOfStream; line = sr.ReadLine(), ++ln)
            {
                if (line == null)
                    continue;

                // strip all comments & whitespace
                line = line.TrimComments().RemoveIf(char.IsWhiteSpace);

                if (line.Length == 0)
                    continue;

                // check for an INI header:
                int eq = line.IndexOf('='), open = line.IndexOf('['), close = line.IndexOf(']');

                if (eq == -1 && open != -1 && close != -1)
                {
                    header = line[(open + 1)..close];
                    doRead = header.Equals("HoldMap", StringComparison.Ordinal);
                }
                else if (doRead)
                {
                    if (eq == -1)
                        continue;

                    // parse the key (coordinate)
                    var coord = line[..eq].RemoveAll('(', ')', ' ').ParsePoint();
                    if (coord == null)
                    {
                        Console.WriteLine($"[WARNING]\tLine {ln} contains an invalid coordinate string! ('{line}')");
                        continue;
                    }

                    // parse the value (region name list)
                    string value = line[(eq + 1)..].Trim();
                    var regionNames = value.ParseArray();
                    byte priority = 56; //< TODO:  Use dynamic priority, as in the original mod

                    List<FormLink<IRegionGetter>> links = new();

                    foreach (string editorID in regionNames)
                    {
                        // check for an already existing region (added by this patcher only) with the given editor ID (name)
                        RegionWrapper? existing = Regions.FirstOrDefault(r => r != null && editorID.Equals(r.EditorID, StringComparison.Ordinal), null);

                        if (existing == null)
                        {
                            string mapName = editorID.ParseRegionMapName();
                            var region = new Region(state.PatchMod.GetNextFormKey(), state.GameRelease.ToSkyrimRelease())
                            {
                                EditorID = editorID,
                                // Region Data
                                Map = new Mutagen.Bethesda.Skyrim.RegionMap()
                                {
                                    Name = mapName,
                                    Header = new RegionMapDataHeader()
                                    {
                                        DataType = RegionData.RegionDataType.Map,
                                        Priority = priority,
                                        Flags = RegionData.RegionDataFlag.Override
                                    },
                                },
                                // Region Areas
                                RegionAreas = new()
                                {
                                    new() // Region Area #0
                                    {
                                        EdgeFallOff = 1024
                                    }
                                }
                            };

                            region.Worldspace.SetTo(Skyrim.Worldspace.Tamriel.FormKey);

                            state.PatchMod.Regions.Add(region);

                            Regions.Add(new(editorID, region.FormKey, mapName));
                            links.Add(region.FormKey);
                        }
                        else
                        {
                            links.Add(existing.FormLink);
                        }
                    }

                    Map.Add(coord.Value, links);
                }
            }
        }

        /// <summary>
        /// Retrieve the list of <see cref="Region"/> formlinks associated with a given cell's coordinates.
        /// </summary>
        /// <param name="coord">The coordinates of the cell to check. <b>This MUST be in cell coordinates, NOT Raw/SubBlock/Block coordinates!</b></param>
        /// <returns>List of formlinks to regions associated with this cell.<br/>If <see cref="Map"/> doesn't contain the given point, an empty list is returned.</returns>
        public List<FormLink<IRegionGetter>> GetFormLinksForPos(Point coord)
        {
            List<FormLink<IRegionGetter>> links = new();

            if (Map.ContainsKey(coord))
            {
                var arr = Map[coord];
                if (arr != null)
                {
                    foreach (var link in arr)
                    {
                        links.Add(link);
                    }
                }
            }

            return links;
        }

        /// <summary>
        /// This is the <see cref="IPatcherState.PatchMod"/>'s <see cref="ILinkCache"/>, for use when resolving records.
        /// </summary>
        private readonly ILinkCache linkCache;

        public List<RegionWrapper> Regions { get; private set; }
        public Dictionary<Point, List<FormLink<IRegionGetter>>> Map { get; private set; }
    }
}
